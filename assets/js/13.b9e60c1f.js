(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{308:function(t,v,e){"use strict";e.r(v);var i=e(0),_=Object(i.a)({},(function(){var t=this,v=t.$createElement,e=t._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h3",{attrs:{id:"vue事件触发"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue事件触发"}},[t._v("#")]),t._v(" Vue事件触发")]),t._v(" "),e("p",[t._v("有这么几种可能性：")]),t._v(" "),e("ul",[e("li",[t._v("子组件设置监听事件以及事件发生时调用的函数，父组件触发")]),t._v(" "),e("li",[t._v("子组件设置监听事件，当事件发生时通知父组件触发")]),t._v(" "),e("li",[t._v("子组件不设置监听事件，父组件设置子组件的自定义事件")]),t._v(" "),e("li",[t._v("子组件不设置监听事件，父组件设置子组件的原生事件")])]),t._v(" "),e("p",[t._v("第一种是不可能的，因为既然在子组件设置了，就没必要在父组件上触发，多此一举。")]),t._v(" "),e("p",[t._v("第二种可以认为是在父组件上使用v-bind和.sync修饰符，在子组件上设置监听事件并触发的操作为this.$emit（...）")]),t._v(" "),e("p",[t._v("第三种必须要子组件也监听事件，然后通过$emit来向父组件通知，.native用在自定义事件上虽然不会报错，但是没有效果。")]),t._v(" "),e("p",[t._v('第四种是父组件在调用子组件的时候，像@click="xxx"这样监听点击事件，但是必须使用@click.native="xxx"的方式。')])])}),[],!1,null,null,null);v.default=_.exports}}]);